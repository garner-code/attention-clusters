# set of functions to perform the group level lme analysis
# Note: many of the model/regressor generator functions are defined in 'att-clust-modelling-pre-reg.Rmd'

HH <- function(beta=1, p){
  # convert p into a predicted RT using the Hick-Hyman Law of decision time
  # kargs
  # -- beta: a value, set to 1 as we'll let the model find beta
  # -- p: a value for a given condition, generated by the models below
  beta*log((1/p)+1)
}

relval <- function(v_x, v_y){
  # get p using relative value function
  # kargs
  # -- v_x: value of target location
  # -- v_y: value of distractor location
  v_x / sum(c(v_x, v_y))
}

L <- function(x, x_prime, y_prime, gamma){
  # calculate the counterfactual loss function
  # kargs:
  # -- x: the outcome
  # -- x_prime: counterfactual outcome
  # -- y_prime: desired outcome
  # -- gamma: preference for x or y'
  gamma * (x_prime - y_prime)^2 + d(x, x_prime)
}

d <- function(x, x_prime){
  # calculate weighting for loss function
  # MAS = median of absolute deviations from the data's median
  dist <- abs(x - x_prime) / median( abs(x - median(c(x, x_prime))))
  if (is.na(dist)) {
    dist <- 0
  }
  dist
}

motiv <- function(ps, vs){
  # compute motivational value
  # kargs:
  # -- ps: probability of each outcome
  # -- vs: value of each outcome
  sum(ps * vs)
}

generate_spatial_regressors <- function(ps, max_val){
  # compute regressor values for each spatial cueing hypothesis
  # kargs:
  # -- ps: probability values to predict RTs for
  # -- max_val: max p in each condition (for the counterfactual regressor)
  spatial <- data.frame(cue_a = ps)
  spatial$cue_b <- 1-ps
  spatial$max_val <- max_val
  spatial <- spatial %>% mutate(sel_hist = HH(p=cue_a))
  
  spatial$counterf <- with(spatial, mapply(L, cue_a, cue_b, max_val, MoreArgs = list(gamma=1)))
  spatial <- spatial %>% mutate(counterf = HH(p=counterf))
  
  spatial <- spatial %>% select(c("cue_a", "sel_hist", "counterf")) %>% pivot_longer(c(sel_hist, counterf), names_to = "model", values_to = "Au") 
  spatial$Au[with(spatial, is.infinite(Au))] = 0
  spatial$cue_a <- as.factor(spatial$cue_a)
  spatial %>% pivot_wider(id_cols = cue_a, names_from = model, values_from = Au)
}


do_cert_models <- function(cert_grp_reg_dat){
  # perform lme models and model selection for the spatial certainty factor
  # kargs:
  # -- cert_grp_reg_dat: data frame of summary rts generated from the post-hoc testing functions,
  #                      combined with spatial regressors
  sel_hist_rt <- lmer(rt~sel_hist + (sel_hist|sub), data=cert_grp_reg_dat, REML = FALSE)
  c_fact_rt <- lmer(rt~counterf + (counterf|sub), data=cert_grp_reg_dat, REML = FALSE)
  grp_cert_comp_rt <- anova(sel_hist_rt, c_fact_rt)
  
  sel_hist_ie <- lmer(ie~sel_hist + (sel_hist|sub), data=cert_grp_reg_dat, REML = FALSE)
  c_fact_ie <- lmer(ie~counterf + (counterf|sub), data=cert_grp_reg_dat, REML = FALSE)
  grp_cert_comp_ie <- anova(sel_hist_ie, c_fact_ie)
  list(sel_hist_rt, c_fact_rt, grp_cert_comp_rt, sel_hist_ie, c_fact_ie, grp_cert_comp_ie)
}

plot_cert_model_vs_subs_rt <- function(cert_grp_reg_dat){
  # plot observed vs predicted data for the selection history model
  # kargs:
  # -- cert_grp_reg_dat: data frame of summary rts generated from the post-hoc testing functions,
  #                      combined with spatial regressors
  cert_grp_reg_dat %>% group_by(cert) %>%
                       summarise(N = length(rt),
                                 rt_mu = mean(rt),
                                 rt_se = sd(rt)/sqrt(N),
                                 ie_mu = mean(ie),
                                 ie_se = sd(ie)/sqrt(N),
                                 pred_rt = mean(pred_sel_hist),
                                 pred_ie = mean(pred_sel_hist_ie)) %>% ungroup() %>%
                       ggplot(aes(x = cert, y = rt_mu, group = 1)) +
                              geom_line() +
                              geom_errorbar(aes(ymin=rt_mu-rt_se, 
                                            ymax=rt_mu+rt_se), width=.2) +
                              geom_line(aes(x=cert, y=pred_rt), linetype = "dashed") +
                              theme_cowplot() +
                              ylim(c(0.5, 0.65))
               
}

generate_value_regressors <- function(value){
  # get the value regressors for the group level modelling
  # kwargs: 
  # -- value - a dataframe containing 
  #     -- cue_a: target value for that trial
  #     -- cue_b: distractor value for that trial
  #     -- max_val: max value available on that trial

  value$rv <- with(value, mapply(relval, cue_a, cue_b))
  value <- value %>% mutate(rv = HH(p=rv))
  
  value$counterf <- with(value, mapply(L, cue_a, cue_b, max_val, MoreArgs = list(gamma=1)))
  value <- value %>% mutate(counterf = HH(p=counterf))
  
  value$mot <- NA
  for (i in 1:4) {
    value$mot[i] <- with(value, motiv(c(.8*.5, .8*.5), c(cue_a[i], cue_b[i])))
  }
  value <- value %>% mutate(mot = HH(p=mot))
  
  
  value <- value %>% select(c(cue_a, cue_b, rv, counterf, mot)) %>% pivot_longer(cols=c(rv, counterf, mot),
                                                                                 names_to = "model",
                                                                                 values_to = "Au")
  
  value$Au[with(value, is.infinite(Au))] = 0 # replacing where 1/0 becomes Inf with log(1)
  value$cue <- rep(c("htgt/ldst", "htgt/hdst", "ltgt/ldst", "ltgt/hdst"), each=3)
  value$cue <- as.factor(value$cue)
  value
}

do_val_models <- function(val_grp_reg_dat){
  # perform lme models and model selection for the incentive value factor
  # kargs:
  # -- val_grp_reg_dat: data frame of summary rts generated from the post-hoc testing functions,
  #                      combined with spatial regressors
  
  # Note that if subject specific slopes were included, then there was boundary (singular) fit
  rv_rt <- lmer(rt ~ rv + (1|sub), data = val_grp_reg_dat, REML = FALSE)
  c_fact_rt <- lmer( rt ~ counterf + (1|sub), data = val_grp_reg_dat, REML = FALSE)
  mot_rt <- lmer(rt ~ mot + (1|sub), data = val_grp_reg_dat, REML = FALSE)
  
  grp_val_comp_rt <- anova(rv_rt, c_fact_rt, mot_rt)
  
  # same here
  rv_ie <- lmer(ie ~ rv + (1|sub), data = val_grp_reg_dat, REML = FALSE)
  c_fact_ie <- lmer(ie~counterf + (1|sub), data = val_grp_reg_dat, REML = FALSE)
  mot_ie <- lmer(ie ~ mot + (1|sub), data = val_grp_reg_dat, REML = FALSE)
  grp_val_comp_ie <- anova(rv_ie, c_fact_ie, mot_ie)
  list(rv_rt, c_fact_rt, mot_rt, grp_val_comp_rt, rv_ie, c_fact_ie, mot_ie, grp_val_comp_ie)
}


plot_val_model_vs_mu_rt_quick <- function(val_grp_reg_dat){
  # quick plot for observed vs predicted data for the counterfactual model
  # kargs:
  # -- val_grp_reg_dat: data frame of summary rts generated from the post-hoc testing functions,
  #                      combined with value regressors and model predictions
  val_grp_reg_dat %>% group_by(reward_type) %>%
    summarise(N = length(rt),
              rt_mu = mean(rt),
              rt_se = sd(rt)/sqrt(N),
              ie_mu = mean(ie),
              ie_se = sd(ie)/sqrt(N),
              pred_rt = mean(pred_cfact_rt),
              pred_ie = mean(pred_cfact_ie)) %>% ungroup() %>%
    ggplot(aes(x = reward_type, y = rt_mu, group = 1)) +
    geom_line() +
    geom_errorbar(aes(ymin=rt_mu-rt_se, 
                      ymax=rt_mu+rt_se), width=.2) +
    geom_line(aes(x=reward_type, y=pred_rt), linetype = "dashed") +
    theme_cowplot() +
    ylim(c(0.5, 0.65))
  
}



